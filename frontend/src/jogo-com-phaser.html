<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>O Ãšltimo GuardiÃ£o - Phaser</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      border: 2px solid #444;
    }
  </style>
</head>
<body>

<script>
const config = {
  type: Phaser.AUTO,
  width: 650,
  height: 450,
  physics: {
    default: 'arcade',
    arcade: { debug: false }
  },
  scene: { preload, create, update }
};

let boss = null;
let player;
let cursors;
let musicTracks = {};
let currentMusic = null;
let bullets = [];
let enemyBullets = [];  // âž• balas inimigas
let canShoot = true;
let shootCooldown = 400;
let mousePointer;
let playerLife = 5;
let hudText;
let currentRoomIndex = 0;
let rooms = [];
let door = { x: 0, y: 0, width: 40, height: 40, open: false, direction: null };
let enemyShootCooldown = 1000; // âž• intervalo de tiro inimigo
let miniMap = [];  // Armazena posiÃ§Ãµes das salas
let miniMapOffset = { x: 3, y: 3 }; // PosiÃ§Ã£o inicial no meio de uma grade 7x7
let visitedRooms = new Set();
let isInvulnerable = false;
let invulnDuration = 2000; // milissegundos
let lastDamageTime = 0;
let blinkInterval;
let bulletSpeed;
let dashKey;
let isDashing = false;
let dashCooldown = 2000; // 1 segundo
let dashDuration = 150;  // duraÃ§Ã£o do dash em ms
let lastDashTime = -dashCooldown;
let dashSpeedMultiplier = 4;
let damageTakenMultiplier = 1;
let shootKeys;
let specialItems = [
  {
    name: "Pergaminho da Velocidade",
    applyEffect: function() {
      player.speed *= 1.5;
      dashSpeedMultiplier *= 1.2;
      dashCooldown /= 1.25; // reduz o cooldown do dash
      damageTakenMultiplier *= 2;
      playerLife += 1;
    },
    description: "Velocidade absurda... mas sofra o dobro de dano."
  },
  {
    name: "Pergaminho da ForÃ§a",
    applyEffect: function() {
      player.damageMultiplier = (player.damageMultiplier || 1) * 2.5; // dobra o dano
      playerLife += 4; // aumenta a vida do jogador
      dashCooldown *= 1.2; // aumenta o cooldown do dash
      dashSpeedMultiplier /= 1.1; // reduz a velocidade do dash 
      player.speed /= 1.1; // reduz a velocidade do jogador                            
    },
    description: "Dano e vida aumetados... mas seu personagem e dash agora sÃ£o mais lentos."
  }, 
  {
    name: "Pergaminho do Poder",
    applyEffect: function() {
      player.bulletSizeMultiplier = (player.bulletSizeMultiplier || 1) * 2; // Aumenta o tamanho do tiro em 50%
      player.multiShotLevel = (player.multiShotLevel || 0) + 1; 
      player.damageMultiplier = (player.damageMultiplier || 1) * 0.75; // Reduz o dano para 65%
      playerLife += 1;
    },
    description: "Dobro de tiros, maiores e mais rÃ¡pidos... mas seu dano Ã© reduzido."
  }
];
let itemKey;
let itemDescription = '';
let itemPickupAvailable = false;

const game = new Phaser.Game(config);

const directions = ['north', 'south', 'east', 'west'];

class Room {
  constructor(name, type = 'combat', next = null) {
    this.name = name;
    this.type = type; // ðŸ†• Tipo da sala: 'combat', 'item' ou 'boss'
    this.next = next;
    this.enemies = [];
    this.cleared = false;
    this.exitDirection = null;
    this.spawned = false;
    this.item = null; // ðŸ†• Para salas de item
  }

    spawnEnemies() {
    const roomIndex = rooms.indexOf(this);
    let chanceBonus = Phaser.Math.Between(0, 100) < roomIndex * 2 ? 2 : 0;
    this.totalEnemiesToSpawn = 3 + Math.floor(roomIndex * 0.75) + chanceBonus;
    this.maxEnemiesPerWave = Math.min(2 + Math.floor(roomIndex / 3), 4);
    this.spawnedEnemies = 0;
    this.waveCooldown = Math.max(10000, 15000 - roomIndex * 100);
    if (this.type === 'boss' || this.type === 'item') return;

    const spawnWave = () => {
      if (!rooms[currentRoomIndex] || this.spawnedEnemies >= this.totalEnemiesToSpawn) return;

      let enemiesToSpawnNow = Math.min(
        this.maxEnemiesPerWave,
        this.totalEnemiesToSpawn - this.spawnedEnemies
      );

      for (let i = 0; i < enemiesToSpawnNow; i++) {

      const minSpawnDistanceFromPlayer = 120;
      let x, y;
      let attempts = 0;
      do {
        x = Phaser.Math.Between(50, config.width - 50);
        y = Phaser.Math.Between(50, config.height - 50);
        attempts++;
      } while (
        Phaser.Math.Distance.Between(x, y, player.x, player.y) < minSpawnDistanceFromPlayer &&
        attempts < 20
      );

        const progress = roomIndex / rooms.length;
        let type;
        const rand = Phaser.Math.Between(1, 100);

        if (rand < 25) {
          type = 'rapido'; 
        } else if (rand < 50) {
          type = 'atirador';
        } else if (rand < 75) {
          type = 'bruto'; 
        } else {
          type = 'normal'; 
        }

        let shoots = false;
        let speed = 50;
        let life = 2;
        let shootCooldown;

        switch (type) {
          case 'rapido':
            speed = 150 + Math.floor(progress * 50);
            life = 2 + Math.floor(progress * 1);
            shoots = false;
            break;
          case 'atirador':
            speed = 50 + Math.floor(progress * 15);
            life = 3 + Math.floor(progress * 2);
            shoots = true;
            bulletSpeed = 150 + Math.floor(progress * 50);
            shootCooldown = Phaser.Math.Between(
              6000 - Math.floor(progress * 250),
              7500 - Math.floor(progress * 350)
            );
            break;
          case 'bruto':
            speed = 125 + Math.floor(progress * 50);
            life = 5 + Math.floor(progress * 3);
            shoots = false;
            break;
          case 'normal':
            speed = 75 + Math.floor(progress * 25);
            life = 3 + Math.floor(progress * 1);
            bulletSpeed = 275 + Math.floor(progress * 75);
            shoots = true;
            shootCooldown = Phaser.Math.Between(
              1000 - Math.floor(progress * 150),
              1500 - Math.floor(progress * 150)
            );
            break;
        }

        const enemy = {
          x,
          y,
          size: 30,
          life,
          active: true,
          lastShot: 0,
          speed,
          shoots,
          type
        };

        if (shoots) {
          enemy.shootCooldown = shootCooldown;
          enemy.bulletSpeed = bulletSpeed;
        }

        this.enemies.push(enemy);
        this.spawnedEnemies++;
      }

      if (this.spawnedEnemies < this.totalEnemiesToSpawn) {
        setTimeout(spawnWave, this.waveCooldown);
      }
    };

    spawnWave();
    this.spawned = true;
  }
}

function preload() {
  this.load.audio('theme_combat', 'audio/music-combat.mp3');
  this.load.audio('theme_item', 'audio/music-item.mp3');
  this.load.audio('theme_boss', 'audio/music-boss.mp3');
  this.load.audio('sfx_hurt', 'audio/sfx-hit.wav');
  this.load.audio('sfx_gameover', 'audio/sfx-game-over.wav');
  this.load.audio('sfx_dash', 'audio/dash-sound.wav');
}

function create() {
  this.cameras.main.setBackgroundColor('#111');
  cursors = this.input.keyboard.addKeys('W,A,S,D');

      shootKeys = this.input.keyboard.addKeys({
      up: Phaser.Input.Keyboard.KeyCodes.UP,
      down: Phaser.Input.Keyboard.KeyCodes.DOWN,
      left: Phaser.Input.Keyboard.KeyCodes.LEFT,
      right: Phaser.Input.Keyboard.KeyCodes.RIGHT
    });

  player = { x: 320, y: 240, size: 40, speed: 150 };

  dashKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

  itemKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

  hudText = this.add.text(10, 10, '', { font: '16px Arial', fill: '#fff' }).setDepth(1);

  const descriptionBg = this.add.graphics().setDepth(0.9);

  descriptionText = this.add.text(20, 320, '', { // <-- alterado de 420 para 320
    fontFamily: 'Verdana',
    fontSize: '12px',
    color: '#ffffaa',
    align: 'left',
    wordWrap: { width: config.width - 40 },
    lineSpacing: 6,
    stroke: '#000000',
    strokeThickness: 3,
    shadow: {
      offsetX: 2,
      offsetY: 2,
      color: '#000000',
      blur: 2,
      stroke: true,
      fill: true
    }
  }).setDepth(1);

  descriptionBg.fillStyle(0x000000, 0.7);
  descriptionBg.fillRoundedRect(10, 310, config.width - 20, 40, 10); // <-- alterado de 410 para 310

  // Atualiza dinamicamente o fundo conforme o tamanho do texto
  this.events.on('postupdate', () => {
    if (descriptionText.text.length > 0) {
      const textHeight = descriptionText.height + 16;
      descriptionBg.clear();
      descriptionBg.fillStyle(0x000000, 0.7);
      descriptionBg.fillRoundedRect(10, 310, config.width - 20, textHeight, 10); // <-- alterado de 410 para 310
      descriptionText.setY(320 + (textHeight - descriptionText.height - 16) / 2); // <-- alterado de 420 para 320
    } else {
      descriptionBg.clear();
    }
  });

  createRooms();
  setDoorPosition();
  playMusicForRoom(this, 'combat');
}

function createRooms() {
  const maxRooms = 13;
  const roomSequence = [
    'combat', 'combat', 'combat', 'item',
    'combat', 'combat', 'combat', 'item',
    'combat', 'combat', 'combat', 'item',
    'boss'
  ];

  rooms = [];

  const opposites = {
    north: 'south',
    south: 'north',
    east: 'west',
    west: 'east'
  };

  const dirOffsets = {
    north: { x: 0, y: -1 },
    south: { x: 0, y: 1 },
    east: { x: 1, y: 0 },
    west: { x: -1, y: 0 }
  };

  let currentPos = { x: 0, y: 0 };
  let usedPositions = new Set(["0,0"]);
  let previousDirection = null;

  for (let i = 0; i < roomSequence.length; i++) {
    const type = roomSequence[i];
    const room = new Room(`Sala ${i + 1} - ${type}`);
    room.type = type;
    room.gridPos = { ...currentPos };
    rooms.push(room);

    if (type === 'item') {
      const item = Phaser.Utils.Array.GetRandom(specialItems);
      room.item = item;
    }

    const possibleDirs = directions.filter(dir =>
      dir !== opposites[previousDirection] && dir !== previousDirection
    );

    let chosenDir = null;
    let attempts = 0;

    while (possibleDirs.length > 0 && attempts < 10) {
      const dir = Phaser.Utils.Array.RemoveRandomElement(possibleDirs);
      const offset = dirOffsets[dir];
      const nextX = currentPos.x + offset.x;
      const nextY = currentPos.y + offset.y;
      const key = `${nextX},${nextY}`;

      if (!usedPositions.has(key)) {
        chosenDir = dir;
        currentPos = { x: nextX, y: nextY };
        usedPositions.add(key);
        break;
      }

      attempts++;
    }

    room.exitDirection = chosenDir;
    previousDirection = chosenDir;

    if (!chosenDir) break;
  }

  for (let i = 0; i < rooms.length - 1; i++) {
    rooms[i].next = rooms[i + 1];
  }

  currentRoomIndex = 0;
  visitedRooms = new Set([0]);

    setTimeout(() => {
      const firstRoom = rooms[0];
      if (firstRoom.type === 'combat') {
        firstRoom.spawnEnemies();
        firstRoom.spawned = true;
      }
    }, 750);

      rooms.forEach(room => {
    if (room.type === 'item') {
      room.cleared = true;
    }
  });

}

function setDoorPosition() {
  const currentRoom = rooms[currentRoomIndex];
  const dir = currentRoom.exitDirection;
  door.direction = dir;
  door.open = false;

  if (currentRoom.type === 'item') {
    door.open = true;
  } else {
    door.open = false;
  }

  switch (dir) {
    case 'north':
      door.x = config.width / 2 - door.width / 2;
      door.y = 0;
      break;
    case 'south':
      door.x = config.width / 2 - door.width / 2;
      door.y = config.height - door.height;
      break;
    case 'east':
      door.x = config.width - door.width;
      door.y = config.height / 2 - door.height / 2;
      break;
    case 'west':
      door.x = 0;
      door.y = config.height / 2 - door.height / 2;
      break;
  }
}

function update(time, delta) {

  const speed = player.speed * (delta / 1000);
  let dx = 0;
  let dy = 0;

  if (cursors.W.isDown) dy -= 1;
  if (cursors.S.isDown) dy += 1;
  if (cursors.A.isDown) dx -= 1;
  if (cursors.D.isDown) dx += 1;

  if (dx !== 0 || dy !== 0) {
    const len = Math.hypot(dx, dy);
    dx /= len;
    dy /= len;

    const now = time;
    if (Phaser.Input.Keyboard.JustDown(dashKey) && now - lastDashTime >= dashCooldown) {
      this.sound.play('sfx_dash');
      isDashing = true;
      lastDashTime = now;
      setTimeout(() => {
        isDashing = false;
      }, dashDuration);
      isInvulnerable = true;
      setTimeout(() => {
        isInvulnerable = false;
      }, dashDuration);
    }

    const currentSpeed = isDashing ? player.speed * dashSpeedMultiplier : player.speed;
    
    player.x += dx * currentSpeed * (delta / 1000);
    player.y += dy * currentSpeed * (delta / 1000);
  }

  if (canShoot) {
  if (shootKeys.up.isDown) {
    shoot('up');
    canShoot = false;
    setTimeout(() => canShoot = true, shootCooldown);
  } else if (shootKeys.down.isDown) {
    shoot('down');
    canShoot = false;
    setTimeout(() => canShoot = true, shootCooldown);
  } else if (shootKeys.left.isDown) {
    shoot('left');
    canShoot = false;
    setTimeout(() => canShoot = true, shootCooldown);
  } else if (shootKeys.right.isDown) {
    shoot('right');
    canShoot = false;
    setTimeout(() => canShoot = true, shootCooldown);
  }
  }

  player.x = Phaser.Math.Clamp(player.x, player.size / 2, config.width - player.size / 2);
  player.y = Phaser.Math.Clamp(player.y, player.size / 2, config.height - player.size / 2);

  const currentRoom = rooms[currentRoomIndex];

  currentRoom.enemies.forEach(enemy => {
    if (!enemy.active) return;
    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const dist = Math.hypot(dx, dy);
    if (dist > 0) {
      enemy.x += (dx / dist) * enemy.speed * (delta / 1000);
      enemy.y += (dy / dist) * enemy.speed * (delta / 1000);
    }

    // âž• Inimigo atira
   if (enemy.shoots && time - enemy.lastShot > enemy.shootCooldown) {
    enemyShoot(enemy);
    enemy.lastShot = time;
   }
  });

  if (currentRoom.type === 'item' && currentRoom.item) {
    const dist = Phaser.Math.Distance.Between(player.x, player.y, config.width / 2, config.height / 2);
    if (dist < 50) {
      itemDescription = `${currentRoom.item.name}: ${currentRoom.item.description}\nPressione [ESPAÃ‡O] para pegar.`;
      itemPickupAvailable = true;

      if (Phaser.Input.Keyboard.JustDown(itemKey)) {
        currentRoom.item.applyEffect();
        currentRoom.item = null;
        itemDescription = '';
        itemPickupAvailable = false;
      }
    } else {
      itemDescription = '';
      itemPickupAvailable = false;
    }
  }


  bullets.forEach(bullet => {
    bullet.x += bullet.vx * (delta / 1000);
    bullet.y += bullet.vy * (delta / 1000);
  });

  bullets = bullets.filter(bullet => {
    let hit = false;
    currentRoom.enemies.forEach(enemy => {
    if (enemy.active && Phaser.Math.Distance.Between(bullet.x, bullet.y, enemy.x, enemy.y) < (enemy.size / 2)) {
        const damage = (player.damageMultiplier || 1);
        enemy.life -= damage;
        bullet.dead = true;
        if (enemy.life <= 0) {
          enemy.active = false;
        }
        hit = true;
      }
    });
    return !bullet.dead;
  });

  if (boss && boss.active) {
    bullets = bullets.filter(bullet => {
      if (Phaser.Math.Distance.Between(bullet.x, bullet.y, boss.x, boss.y) < (boss.size / 2)) {
        const damage = (player.damageMultiplier || 1);
        boss.life -= damage;
        bullet.dead = true; // Marca a bala para remoÃ§Ã£o

        if (boss.life <= 0) {
          boss.active = false;
          // VitÃ³ria! A porta se abrirÃ¡
        }
        return false; // Remove a bala
      }
      return true; // MantÃ©m a bala
    });
  }
  // âž• movimentaÃ§Ã£o das balas inimigas
  enemyBullets.forEach(bullet => {
    bullet.x += bullet.vx * (delta / 1000);
    bullet.y += bullet.vy * (delta / 1000);
  });

  enemyBullets = enemyBullets.filter(bullet => {
  if (
    Phaser.Math.Distance.Between(bullet.x, bullet.y, player.x, player.y) < player.size / 2 &&
    !isInvulnerable
  ) {
    takeDamage(this); // ðŸ‘ˆ Usa a funÃ§Ã£o que ativa invulnerabilidade e piscar
    return false; // Remove a bala
  }
    return bullet.x > 0 && bullet.x < config.width && bullet.y > 0 && bullet.y < config.height;
  });

  currentRoom.enemies.forEach(enemy => {
  if (!enemy.active) return;
  if (Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y) < (player.size / 2)) {
    if (!isInvulnerable) {
        takeDamage(this);
      }
    }
  });

    if (boss && boss.active) {
    if (Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y) < (player.size / 2 + boss.size / 2)) {
      if (!isInvulnerable) {
        takeDamage(this);
      }
    }
  }

  if (boss && boss.active) {
    // Movimento simples do chefe (segue o jogador lentamente)
    const dx = player.x - boss.x;
    const dy = player.y - boss.y;
    const dist = Math.hypot(dx, dy);
    if (dist > 0) {
      boss.x += (dx / dist) * boss.speed * (delta / 1000);
      boss.y += (dy / dist) * boss.speed * (delta / 1000);
    }

    // Chama a funÃ§Ã£o de ataque do chefe
    bossAttack(time, this);
  }
  
if (currentRoom.type === 'item') {
    door.open = true;
    currentRoom.cleared = true;
  } else if (!currentRoom.cleared) {
      // CondiÃ§Ã£o para salas de combate normais
      const combatRoomCleared = currentRoom.type === 'combat' &&
                                currentRoom.spawned &&
                                currentRoom.enemies.length > 0 &&
                                currentRoom.enemies.every(e => !e.active);

      // CondiÃ§Ã£o para a sala do chefe
      const bossRoomCleared = currentRoom.type === 'boss' &&
                              boss && !boss.active;

      if (combatRoomCleared || bossRoomCleared) {
          currentRoom.cleared = true;
          door.open = true;
      }
  }

  if (door.open && checkPlayerAtDoor()) {
    if (currentRoom.next) {
      currentRoomIndex++;
      visitedRooms.add(currentRoomIndex);
      bullets = [];
      enemyBullets = [];
      movePlayerToNewPosition();
      setDoorPosition();

      const nextRoom = rooms[currentRoomIndex];

      playMusicForRoom(this, nextRoom.type);

      if (!nextRoom.spawned) {
        setTimeout(() => {
          if (nextRoom.type === 'boss') {
            spawnBoss(this);
          } else {
            nextRoom.spawnEnemies();
          }
          nextRoom.spawned = true;
        }, 2000);
      }
    } else {
      // CondiÃ§Ã£o de vitÃ³ria final
      alert("ParabÃ©ns! VocÃª derrotou o GuardiÃ£o Final e salvou este mundo!");
      location.reload();
    }
  }

  separateEnemies(currentRoom.enemies);
  hudText.setText(`Vida: ${Math.ceil(playerLife)} | ${currentRoom.name}`);
  draw(this);

  descriptionText.setText(itemDescription);
}

function draw(scene) {
  scene.cameras.main.setBackgroundColor('#111');
  scene.children.list.forEach(child => {
    if (child.type === "Graphics") child.destroy();
  });

  const g = scene.add.graphics();

  // Porta
  g.fillStyle(door.open ? 0x00ff00 : 0xff0000, 1);
  g.fillRect(door.x, door.y, door.width, door.height);

  // Jogador
  if (player.visible !== false) {
    g.fillStyle(0x00ff00, 1);
    g.fillRect(
      player.x - player.size / 2,
      player.y - player.size / 2,
      player.size,
      player.size
    );
  }

  // Inimigos
  const currentRoom = rooms[currentRoomIndex];
  currentRoom.enemies.forEach(enemy => {
    if (!enemy.active) return;
    let color = 0xff0000;
    switch (enemy.type) {
      case 'bruto': color = 0xff9900; break;
      case 'rapido': color = 0x66ccff; break;
      case 'atirador': color = 0x000080; break;
    }
    g.fillStyle(color, 1);
    g.fillRect(
      enemy.x - enemy.size / 2,
      enemy.y - enemy.size / 2,
      enemy.size,
      enemy.size
    );
  });

  if (boss && boss.active) {
    // Corpo do chefe
    g.fillStyle(0x8B008B, 1); // Roxo escuro
    g.fillRect(
      boss.x - boss.size / 2,
      boss.y - boss.size / 2,
      boss.size,
      boss.size
    );

    // Barra de vida do chefe
    const healthBarWidth = 150;
    const healthBarHeight = 15;
    const healthBarX = config.width / 2 - healthBarWidth / 2;
    const healthBarY = 20;

    // Fundo da barra de vida
    g.fillStyle(0x333333, 1);
    g.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

    // Vida atual
    const currentHealthWidth = (boss.life / boss.maxLife) * healthBarWidth;
    g.fillStyle(0xff0000, 1);
    g.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);
  }

  // ðŸ”¥ Balas do jogador com tamanho dinÃ¢mico
  bullets.forEach(bullet => {
    const s = bullet.size; // Usa o tamanho da bala corretamente
    g.fillStyle(0xffff00, 1);
    g.fillRect(
      bullet.x - s / 2,
      bullet.y - s / 2,
      s,
      s
    );
  });

  // âž• Balas dos inimigos (mantÃ©m o tamanho padrÃ£o delas)
  enemyBullets.forEach(bullet => {
    g.fillStyle(0xff00ff, 1);
    g.fillRect(bullet.x - 4, bullet.y - 4, 8, 8);
  });

  // Item (pergaminho)
  if (currentRoom.type === 'item' && currentRoom.item) {
    g.fillStyle(0xffff00, 1);
    g.fillRect(
      config.width / 2 - 15,
      config.height / 2 - 15,
      30,
      30
    );
  }
}

function shoot(direction, scene) {
  const baseSpeed = 300;
  let baseAngle = 0;

  switch (direction) {
    case 'up': baseAngle = -Math.PI / 2; break;
    case 'down': baseAngle = Math.PI / 2; break;
    case 'left': baseAngle = Math.PI; break;
    case 'right': baseAngle = 0; break;
  }

  const sizeMultiplier = player.bulletSizeMultiplier || 1;
  const bulletSize = 8 * sizeMultiplier;  

  const level = player.multiShotLevel || 0;
  const numberOfBullets = Math.pow(2, level); // 1, 2, 4, 8...

  const spreadAngle = 0.2;

  for (let i = 0; i < numberOfBullets; i++) {
    // Distribui os tiros simetricamente em arco
    const angleOffset = (i - (numberOfBullets - 1) / 2) * spreadAngle;
    const angle = baseAngle + angleOffset;

    const vx = Math.cos(angle) * baseSpeed;
    const vy = Math.sin(angle) * baseSpeed;

    let bullet = {
      x: player.x,
      y: player.y,
      vx: vx,
      vy: vy,
      size: bulletSize
    };
    bullets.push(bullet);
  }
}

// âž• funÃ§Ã£o inimigo atira
function enemyShoot(enemy) {
  if (!enemy.active || enemy.life <= 0 || !enemy.shoots) return;

  const now = Date.now();
  if (now - (enemy.lastShot || 0) < enemy.shootCooldown) return;
  enemy.lastShot = now;

  if (enemy.type === 'atirador') {
    // Rajada em arco
    const numBullets = 9;
    const spread = Math.PI / 2; // 90 graus
    const baseAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
    const startAngle = baseAngle - spread / 2;
    const delayPerShot = 50;

    for (let i = 0; i < numBullets; i++) {
      setTimeout(() => {
        if (!enemy.active || enemy.life <= 0) return;

        const angle = startAngle + (spread / (numBullets - 1)) * i;
        const vx = Math.cos(angle) * enemy.bulletSpeed;
        const vy = Math.sin(angle) * enemy.bulletSpeed;

        const bullet = {
          x: enemy.x,
          y: enemy.y,
          vx,
          vy,
          fromEnemy: true
        };

        enemyBullets.push(bullet);
      }, i * delayPerShot);
    }
  } else {
    // Tiro Ãºnico normal
    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const len = Math.hypot(dx, dy);
    const bullet = {
      x: enemy.x,
      y: enemy.y,
      vx: (dx / len) * enemy.bulletSpeed,
      vy: (dy / len) * enemy.bulletSpeed,
      fromEnemy: true
    };
    enemyBullets.push(bullet);
  }
}


function checkPlayerAtDoor() {
  return (
    player.x + player.size / 2 >= door.x &&
    player.x - player.size / 2 <= door.x + door.width &&
    player.y + player.size / 2 >= door.y &&
    player.y - player.size / 2 <= door.y + door.height
  );
}

function movePlayerToNewPosition() {
  switch (door.direction) {
    case 'north':
      player.y = config.height - player.size;
      break;
    case 'south':
      player.y = player.size;
      break;
    case 'east':
      player.x = player.size;
      break;
    case 'west':
      player.x = config.width - player.size;
      break;
  }
}

function takeDamage(scene) {
  const damage = 1 * damageTakenMultiplier;
  playerLife -= damage;

  scene.sound.play('sfx_hurt', { volume: 0.6 });

  isInvulnerable = true;
  lastDamageTime = Date.now();

  if (playerLife <= 0) {
    scene.sound.stopAll();
    scene.sound.play('sfx_gameover');
    alert("Game Over!");
    location.reload();
    return;
  }

  let blink = true;
  blinkInterval = setInterval(() => {
    player.visible = blink;
    blink = !blink;
  }, 75);

  setTimeout(() => {
    clearInterval(blinkInterval);
    player.visible = true;
    isInvulnerable = false;
  }, invulnDuration);
}

function separateEnemies(enemies) {
  const minDistance = 33; // distÃ¢ncia mÃ­nima entre centros dos inimigos

  for (let i = 0; i < enemies.length; i++) {
    const e1 = enemies[i];
    if (!e1.active) continue;

    for (let j = i + 1; j < enemies.length; j++) {
      const e2 = enemies[j];
      if (!e2.active) continue;

      const dx = e2.x - e1.x;
      const dy = e2.y - e1.y;
      const dist = Math.hypot(dx, dy);

      if (dist > 0 && dist < minDistance) {
        const overlap = (minDistance - dist) / 2;
        const nx = dx / dist;
        const ny = dy / dist;

        e1.x -= nx * overlap;
        e1.y -= ny * overlap;
        e2.x += nx * overlap;
        e2.y += ny * overlap;
      }
    }
  }
}

function spawnBoss(scene) {
  boss = {
    x: config.width / 2,
    y: 100,
    size: 80,
    life: 100,
    maxLife: 100,
    active: true,
    speed: 75,
    phase: 1, // O chefe terÃ¡ fases diferentes
    attackCooldown: 2500, // Tempo entre ataques
    lastAttackTime: 0,
    // Para o ataque em espiral
    spiralAngle: 0
  };
}

function bossAttack(time, scene) {
  if (!boss || !boss.active || time < boss.lastAttackTime + boss.attackCooldown) {
    return;
  }
  boss.lastAttackTime = time;

  // LÃ³gica de ataque baseada na fase (vida)
  const lifePercent = boss.life / boss.maxLife;

  // Fase 2: Abaixo de 50% de vida
  if (lifePercent < 0.5 && boss.phase === 1) {
    boss.phase = 2;
    boss.speed *= 1.5; // Fica mais rÃ¡pido
    boss.attackCooldown = 1800; // Ataca mais rÃ¡pido
    // Efeito visual ou sonoro de fÃºria poderia ser adicionado aqui
  }

  // Escolhe um ataque aleatÃ³rio
  const attackType = Phaser.Math.Between(1, 3);

  if (attackType === 1) { // Ataque 1: Rajada de tiros teleguiados
    const numBullets = (boss.phase === 1) ? 3 : 5;
    const delayPerShot = 150;
    for (let i = 0; i < numBullets; i++) {
      setTimeout(() => {
        if (!boss.active) return;
        const dx = player.x - boss.x;
        const dy = player.y - boss.y;
        const len = Math.hypot(dx, dy);
        enemyBullets.push({
          x: boss.x, y: boss.y,
          vx: (dx / len) * 200, vy: (dy / len) * 200,
          fromEnemy: true
        });
      }, i * delayPerShot);
    }
  } else { // Ataque 2: Espiral de projÃ©teis
    const numBulletsInSpiral = 16;
    for (let i = 0; i < numBulletsInSpiral; i++) {
        const angle = boss.spiralAngle + (i * (2 * Math.PI / numBulletsInSpiral));
        const bulletSpeed = (boss.phase === 1) ? 150 : 200;
        const vx = Math.cos(angle) * bulletSpeed;
        const vy = Math.sin(angle) * bulletSpeed;
        enemyBullets.push({ x: boss.x, y: boss.y, vx, vy, fromEnemy: true });
    }
    boss.spiralAngle += 0.5; // Rotaciona a espiral para o prÃ³ximo ataque
  }
}

function playMusicForRoom(scene, roomType) {
  let musicKey;

  // Decide qual mÃºsica tocar com base no tipo da sala
  if (roomType === 'boss') {
    musicKey = 'theme_boss';
  } else if (roomType === 'item') {
    musicKey = 'theme_item';
  } else {
    musicKey = 'theme_combat';
  }

  // Se a mÃºsica certa jÃ¡ estiver tocando, nÃ£o faz nada
  if (currentMusic && currentMusic.key === musicKey) {
    return;
  }

  // Para qualquer mÃºsica que estiver tocando
  if (currentMusic) {
    currentMusic.stop();
  }

  // Toca a nova mÃºsica em loop e com volume mais baixo
  currentMusic = scene.sound.add(musicKey, { loop: true, volume: 0.4 });
  currentMusic.play();
}

</script>
</body>
</html>